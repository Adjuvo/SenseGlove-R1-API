{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is this?","text":"<p>This is the python API to interface with Rembrandt, an active force feedback glove with precise position tracking made for telerobotics by SenseGlove. With this API you can retrieve tracking data in many formats, and control the active force feedback pulling on the fingers in the glove. </p> <p>\u26a0\ufe0f In Development - Please give your feedback!</p> <p>Both the product and the API are still under development and are subject to change. If you require certain functionality from the API, we would be happy to receive your feedback!</p>"},{"location":"#ros-vs-ros2-support","title":"ROS vs ROS2 support","text":"<p>ROS2 is supported. Please let us know if your project requires ROS1. Our current API also supports ROS1, requiring python 3.8.x.</p>"},{"location":"#documentation-sections","title":"\ud83d\udcda Documentation Sections","text":"<p>\ud83d\ude80 Getting Started - Installation and basic examples. Read this first! \ud83c\udfaf Tracking Data - Finger tracking and position data \u26a1 Control - Force feedback \ud83e\udd16 Robot hand mapper - Robot hand mapper, easily map to robot hands. \ud83d\udcd6 API Reference - Available functions and their docs.</p> <p>\ud83d\udce6 Releases - Changelog of new releases</p>"},{"location":"api-reference/","title":"API Reference","text":"<ul> <li>The functions you will need are in SG_main. </li> <li>For details on the simulator to work without physical gloves see SG_simulator</li> </ul>"},{"location":"api-reference/#SG_API.SG_main","title":"SG_API.SG_main","text":"<p>SG_main contains all functions the user needs from the API. See Getting Started docs for a general explanation of how to use it.</p> <p>Questions? Written by: - Amber Elferink Docs:    https://senseglove.gitlab.io/rembrandt/rembrandt-api Support: https://www.senseglove.com/support/</p>"},{"location":"api-reference/#SG_API.SG_main.init","title":"init","text":"Python<pre><code>init(wait_for_x_gloves: int, com_type: Com_type, SIMULATION_MODE: Simulation_Mode = SG_sim.Simulation_Mode.FINGERS_OPEN_CLOSE) -&gt; List[int]\n</code></pre> <p>Initializes the API and connection searching. </p> <p>If wait_for_x_gloves is not 0, the program will not move on until it finds at least x gloves. Returns list of device_ids connected after init.</p> <p>If setting Com_type to SIMULATED_GLOVE it will generate a single right hand simulator. The movement can be set with the SIMULATION_MODE parameter (which is not used when the REAL glove mod is on).</p> <p>Examples: Python<pre><code>device_ids = SG_main.init(1, SG_T.Com_type.REAL_GLOVE_USB)  # Block program until 1 glove connects\ndevice_ids = SG_main.init(2, SG_T.Com_type.REAL_GLOVE_USB)  # Block program until 2 gloves connect\ndevice_ids = SG_main.init(1, SG_T.Com_type.SIMULATED_GLOVE)  # Simulate 1 glove (max 1 simulated glove via this init, create more with init_rembrandt_sim())\ndevice_ids = SG_main.init(0, SG_T.Com_type.REAL_GLOVE_USB)  # Doesn't block the program, may return no device_ids. \n</code></pre> If you choose to set it to 0, you can use the <code>add_on_connected_callback()</code> function to capture the device_id on connection, or retrieve the device_ids with <code>get_device_ids()</code>, <code>get_right_hand_deviceid()</code>, <code>get_left_hand_deviceid()</code> after a connection.</p>"},{"location":"api-reference/#SG_API.SG_main.init_rembrandt_sim","title":"init_rembrandt_sim","text":"Python<pre><code>init_rembrandt_sim(handedness: Hand, simulation_mode: Simulation_Mode, starting_angles=[0.0, -0.2617993877991494, 0.7853981633974483, -1.5707963267948966, 2.0943951023931953, -1.7453292519943295, 1.5707963267948966, 0.7]) -&gt; Optional[Glove_Simulator]\n</code></pre> <p>Creates a simulated hand to test without physical Rembrandt glove. For more options directly create it via SG_sim.create_glove_sim_device(). Currently does max 2 gloves from this function. A right and a left one.</p> <p>Examples: Python<pre><code>right_sim = SG_main.init_rembrandt_sim(SG_T.Hand.RIGHT, SG_sim.Simulation_Mode.FINGERS_OPEN_CLOSE)\nleft_sim = SG_main.init_rembrandt_sim(SG_T.Hand.LEFT, SG_sim.Simulation_Mode.STATIC)\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.get_COM_type","title":"get_COM_type","text":"Python<pre><code>get_COM_type(device_id: int) -&gt; Com_type\n</code></pre> <p>Returns the communication type of the specified device. Use: Python<pre><code>com_type = SG_main.get_COM_type(device_id)\n</code></pre></p> <p>Examples: Python<pre><code>com_type = SG_main.get_COM_type(12345)  # SG_T.Com_type.REAL_GLOVE_USB or SG_T.Com_type.SIMULATED_GLOVE\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.keep_program_running","title":"keep_program_running","text":"Python<pre><code>keep_program_running()\n</code></pre> <p>This is a while true loop with a sleep and exit check.  Exits cleanly on Ctrl+C, window close, or stop_program_running()</p> <p>\u26a0\ufe0f Important Notes</p> <ol> <li>Code after this call will NOT execute until exit</li> <li>Use this instead of a custom while loop to avoid performance issues with 1000hz glove data (subscr_rembrandt_data_callback)</li> </ol> <p>Usage: Python<pre><code>SG_main.subscr_rembrandt_data_callback(on_new_data)\nSG_main.keep_program_running()\n# code here won't execute until exit\n</code></pre></p> <p>How it's implemented (for reference): Python<pre><code>def keep_program_running():\n    try:\n        while SG_main.SG_cb.running:\n            time.sleep(1)  # This loop does not do anything but keep the program alive. Some sleep is important to not eat all CPU capacity.\n    except: \n        pass # important errors will still log due to sg_logger. This try/except just ignores the keyboard interrupt error on Ctrl+C.\n</code></pre></p> <p>If you use your own while loop instead (without the sleep), that may steal all CPU capacity, and the data callback will not be called often, which can result in only 70fps glove data update rate in bad cases.</p> <p>So if you use your own while loop, make sure to add the sleep, and preferably the shutdown check for clean exit.</p>"},{"location":"api-reference/#SG_API.SG_main.is_device_active","title":"is_device_active","text":"Python<pre><code>is_device_active(device_id: int) -&gt; bool\n</code></pre> <p>Checks if a device with given device_id is currently active/connected. Use: Python<pre><code>is_active = SG_main.is_device_active(device_id)\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.get_device_ids","title":"get_device_ids","text":"Python<pre><code>get_device_ids() -&gt; List[int]\n</code></pre> <p>Returns list with device_ids of all active devices.  </p> <p>Examples: Python<pre><code>device_ids = SG_main.get_device_ids()  # [123, 678] - two gloves connected\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.get_right_hand_deviceid","title":"get_right_hand_deviceid","text":"Python<pre><code>get_right_hand_deviceid() -&gt; Optional[int]\n</code></pre> <p>Returns the first right hand device_id found in active devices. Use: Text Only<pre><code>right_id = SG_main.get_right_hand_deviceid() #returns device_id, or None if no right hand\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.get_left_hand_deviceid","title":"get_left_hand_deviceid","text":"Python<pre><code>get_left_hand_deviceid() -&gt; Optional[int]\n</code></pre> <p>Returns the first left hand device_id found in active devices.</p> <p>Examples:</p> Python<pre><code>left_id = SG_main.get_left_hand_deviceid()  # returns device_id or None if no left hand\n</code></pre>"},{"location":"api-reference/#SG_API.SG_main.is_left_hand","title":"is_left_hand","text":"Python<pre><code>is_left_hand(device_id: int)\n</code></pre> <p>Checks if a device is left handed. Returns True for left hand, False for right hand.</p> Python<pre><code>is_left = SG_main.is_left_hand(device_id)\n</code></pre>"},{"location":"api-reference/#SG_API.SG_main.get_handedness","title":"get_handedness","text":"Python<pre><code>get_handedness(device_id: int) -&gt; Hand\n</code></pre> <p>Returns the handedness (left or right) of the specified device.</p> Python<pre><code>handedness = SG_main.get_handedness(device_id)   # SG_T.Hand.LEFT or SG_T.Hand.RIGHT\n</code></pre>"},{"location":"api-reference/#SG_API.SG_main.nr_of_fingers_tracking","title":"nr_of_fingers_tracking","text":"Python<pre><code>nr_of_fingers_tracking(device_id: int)\n</code></pre> <p>Returns the number of fingers supported by the device for tracking. Use: Python<pre><code>finger_count = SG_main.nr_of_fingers_tracking(device_id)\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.nr_of_fingers_force","title":"nr_of_fingers_force","text":"Python<pre><code>nr_of_fingers_force(device_id: int)\n</code></pre> <p>Returns the number of fingers supported by the device for force feedback. Use: Python<pre><code>finger_count = SG_main.nr_of_fingers_force(device_id)\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.subscr_r1_data_callback","title":"subscr_r1_data_callback","text":"Python<pre><code>subscr_r1_data_callback(cb: Callable[[int], None])\n</code></pre> <p>Expects a callback function that takes device_id as a parameter. </p> <p>That function will trigger if new data is available for the Rembrandt device. Within your function, call other API functions to retrieve specific data.</p> <p>\u26a0\ufe0f Important Note</p> <p>Do not put too heavy computing into this callback, since it will slow down the update rate of data retrieval from the glove, which must remain ~1kHz for optimal haptic performance. Preferably only place data into variables here.</p> Python<pre><code># on_new_data will be called when new data is available for the Rembrandt device\ndef on_new_data(device_id): \n    angles = SG_main.get_exo_angles_rad(device_id)\n\nSG_main.add_r1_data_callback(on_new_data)  # subscribes on_new_data to be called\n</code></pre>"},{"location":"api-reference/#SG_API.SG_main.subscr_on_connected_callback","title":"subscr_on_connected_callback","text":"Python<pre><code>subscr_on_connected_callback(cb: Callable[[Device_Info], None])\n</code></pre> <p>Expects a callback function that takes SG_types.Device_Info as a parameter. </p> <p>That function will trigger if a new device is connected. Within your function, call other API functions to retrieve specific data.</p> <p>You can add the following code even before the SG_main.init() call to make sure you capture the connection.. Python<pre><code>def on_new_device(device_info):\n    print(f\"New device connected: {device_info.device_id}\")\nSG_main.add_on_connected_callback(on_new_device)\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.get_exo_angles_rad","title":"get_exo_angles_rad","text":"Python<pre><code>get_exo_angles_rad(device_id: int) -&gt; Sequence[Sequence[float]]\n</code></pre> <p>Retrieves exoskeleton joint angles in radians.</p> Python<pre><code>exo_angles = SG_main.get_exo_angles_rad(device_id)\n</code></pre> <p>Can be indexed like:</p> <ul> <li><code>exo_angle = exo_angles[finger_nr][exo_joint_nr]</code></li> </ul> <p>Angle definitions: </p> <ul> <li>A fully extended straight exoskeleton gives all angles 0</li> <li>Rotating a joint towards hand palm gives angle &gt; 0</li> <li>Rotating joint towards back of hand angle &lt; 0 </li> <li>The first angle is the splay angle. Those after are the flexion angles</li> </ul> <p>Examples: Python<pre><code>thumb_splay_angle = exo_angles[0][0]  # thumb splay angle in radians\nindex_flex1_angle = exo_angles[1][1]  # index finger 1st flexion in radians\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.get_device_info","title":"get_device_info","text":"Python<pre><code>get_device_info(device_id: int) -&gt; Device_Info\n</code></pre> <p>Returns the device info (such as firmware version, nr_fingers, handedness, etc) for the specified device. Use: Python<pre><code>device_info = SG_main.get_device_info(device_id)\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.get_exo_angles_deg","title":"get_exo_angles_deg","text":"Python<pre><code>get_exo_angles_deg(device_id: int) -&gt; Sequence[Sequence[float]]\n</code></pre> <p>Retrieves exoskeleton joint angles in degrees (same as get_exo_angles_rad but degrees). Use: Python<pre><code>exo_angles = SG_main.get_exo_angles_deg(device_id)\n</code></pre></p> <p>Examples: Python<pre><code>thumb_splay_deg = exo_angles[0][0]  # thumb splay angle in degrees\nindex_flex1_angle = exo_angles[1][1]  # index finger 1st flexion in degrees\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.get_exo_linkage_lengths","title":"get_exo_linkage_lengths","text":"Python<pre><code>get_exo_linkage_lengths(device_id: int) -&gt; Sequence[Sequence[Union[int, float]]]\n</code></pre> <p>Returns the linkage lengths of the exoskeleton for the specified device in mm. Use: Python<pre><code>linkage_lengths = SG_main.get_exo_linkage_lengths(device_id) # [11.62, 35, 35, 35, 35, 35, 35, 10] # in mm\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.get_fingertips_pos_rot","title":"get_fingertips_pos_rot","text":"Python<pre><code>get_fingertips_pos_rot(device_id: int) -&gt; Tuple[Sequence[Vec3_type], Sequence[Quat_type]]\n</code></pre> <p>Returns tuple of positions (x,y,z) and rotations (quat) of each fingertip with respect to the finger base origin. See tracking documentation for more info.</p> Python<pre><code>fingertips_pos, fingertips_rot = SG_main.get_fingertips_pos_rot(device_id)\n</code></pre> <p>Can be indexed like:</p> <ul> <li><code>fingertip_pos_xyz = fingertips_pos[finger_nr][xyz_index]</code></li> <li><code>fingertip_rot_quat = fingertips_rot[finger_nr][quat_wxyz_index]</code></li> </ul> <p>Examples: Python<pre><code>thumb_pos_x = fingertips_pos[0][0]  # thumb x position\nindex_rot_w = fingertips_rot[1][0]  # index finger quaternion w\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.get_fingertip_thimble_dims","title":"get_fingertip_thimble_dims","text":"Python<pre><code>get_fingertip_thimble_dims(device_id: int) -&gt; List[Thimble_dims]\n</code></pre> <p>Returns thimble dimensions info for each fingertip to approximate its drawing with sphere and a cylinder. See SG_types.Thimble_dims for more info. Python<pre><code>thimble_dims = SG_main.get_fingertip_thimble_dims(device_id)\n</code></pre></p> <p>Example: Python<pre><code>thumb_dims = thimble_dims[0].radius  # thumb thimble radius\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.get_exo_joints_poss_rots","title":"get_exo_joints_poss_rots","text":"Python<pre><code>get_exo_joints_poss_rots(device_id: int) -&gt; Tuple[Sequence[Sequence[Vec3_type]], Sequence[Sequence[Quat_type]]]\n</code></pre> <p>Returns tuple of positions (x,y,z) and rotations (quat) of each exoskeleton joint. Use:  Python<pre><code>exo_poss, exo_rot = SG_main.get_exo_joints_poss_rots(hand_id)\n</code></pre> Can be indexed like:  - <code>joint_pos_xyz = exo_poss[finger_nr][exo_joint_nr][xyz_index]</code> - <code>joint_rot_quat = exo_rot[finger_nr][exo_joint_nr][quat_wxyz_index]</code></p> <p>Examples: Python<pre><code>thumb_flexion_1_z: exo_poss[0][1][2] # thumb 1st flexion joint z\nmiddlefinger_splay_y: exo_poss[2][0][1] # middle finger splay joint y\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.get_percentage_bents","title":"get_percentage_bents","text":"Python<pre><code>get_percentage_bents(device_id: int) -&gt; Tuple[Sequence[int], Sequence[int]]\n</code></pre> <p>Returns percentage bent values for flexion and abduction of each finger.</p> <p>Returns tuple containing:</p> <ul> <li>flexion_perc_bents: Array of flexion percentages (0-out_max_perc_bent, 10000 by default)</li> <li>abduction_perc_bents: Array of abduction percentages (0-out_max_perc_bent, 10000 by default)</li> </ul> Python<pre><code>flex_bents, abd_bents = SG_main.get_percentage_bents(device_id)\n</code></pre> <p>Can be indexed like:</p> <ul> <li><code>finger_flex_bent = flex_bents[finger_nr]</code></li> <li><code>finger_abd_bent = abd_bents[finger_nr]</code></li> </ul> <p>Examples: Python<pre><code>thumb_flex_bent = flex_bents[0]  # 0 (open) to 10000 (closed)\nthumb_abd_bent = abd_bents[0]    # 0 (in plane with palm) to 10000 (maximally radially extended)\nindex_abd_bent = abd_bents[1]    # 0 abducted to y, 5000 (neutral) to 10000 (abducted to the -y)\n</code></pre></p> <p>Notes:</p> <ul> <li>Values range from 0 (finger open) to out_max_perc_bent (finger closed)</li> <li>For the thumb:<ul> <li>Flexion: 0 = extended, out_max_perc_bent = fully flexed</li> <li>Abduction: 0 = in plane with palm, out_max_perc_bent = maximally radially extended</li> </ul> </li> <li>For other fingers:<ul> <li>Flexion: 0 = extended, out_max_perc_bent = fully flexed</li> <li>Abduction: 0 = neutral, out_max_perc_bent = maximally abducted</li> </ul> </li> </ul> <p>Other notes:</p> <ul> <li>10000 is used by default instead of 100 to avoid floating point inaccuracies</li> <li>It calculates this based on the fingertip orientation with respect to the finger base orientation</li> <li>This method is used because it's independent of user hand sizes, and requires no calibration</li> <li>Use set_perc_bent_vars() to change the max perc bent values to control and how 0 and 10000 are mapped to the raw values (from raw_percentage_bent_angles())</li> </ul>"},{"location":"api-reference/#SG_API.SG_main.get_raw_percentage_bent_angles","title":"get_raw_percentage_bent_angles","text":"Python<pre><code>get_raw_percentage_bent_angles(device_id: int) -&gt; Tuple[Sequence[float], Sequence[float]]\n</code></pre> <p>Returns the raw flexion and abduction angles used to calculate percentage bent. Returns: (flex_angles, abd_angles) Each is an array of the fingers, containing the raw angles in radians. See the tracking documentation for more info. Use: Python<pre><code>flex_angles, abd_angles = SG_main.get_raw_percentage_bent_angles(device_id)\n</code></pre> Can be indexed like: - <code>finger_flex_angle = flex_angles[finger_nr]</code> - <code>finger_abd_angle = abd_angles[finger_nr]</code></p> <p>Examples: Python<pre><code>thumb_flex = flex_angles[0]  # thumb flexion angle in radians\nindex_abd = abd_angles[1]   # index abduction angle in radians\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.set_percentage_bent_vars","title":"set_percentage_bent_vars","text":"Python<pre><code>set_percentage_bent_vars(device_id: int, min_thetas_flexion: NDArray[float64] = np.array([0, 0.524, 0.345, 0.414, 0.4]), max_thetas_flexion: NDArray[float64] = np.array([1.8, 3.265, 3.0, 3.0, 2.75]), min_thetas_abduction: NDArray[float64] = np.array([0.0, -0.3, -0.3, -0.3, -0.3]), max_thetas_abduction: NDArray[float64] = np.array([0.5, 0.3, 0.3, 0.3, 0.3]), out_max_perc_bent: int = 10000)\n</code></pre> <p>Sets the variables used to calculate percentage bent values. With this you can override when a finger is considered bent or open:</p> <p>Steps:</p> <ol> <li>Monitor your values from get_raw_percentage_bent_angles()</li> <li>Move your fingers and note down the values per finger of your desired bent and open</li> <li>Set the min and max values to the values you noted down on startup of your program, just after init()</li> </ol> <p>Example: Python<pre><code>device_ids = SG_main.init(1, SG_T.Com_type.REAL_GLOVE_USB)\ndevice_id = device_ids[0]\nSG_main.set_percentage_bent_vars(device_id, \n    min_flex = [0.23, -0.27, -0.27, -0.27, 0.1], \n    max_flex = [1.00, 2.75, 2.75, 2.75, 2.75], \n    min_abd = [0.04, -0.18, -0.27, -0.27, 0.1], \n    max_abd = [0.6, 0.18, 0.27, 0.27, 0.1])\n\n# using SG_main.get_percentage_bents(device_id) you can now see the adjusted percentage bent values for each finger.\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.create_robot_hand_mapper","title":"create_robot_hand_mapper","text":"Python<pre><code>create_robot_hand_mapper(device_id: int, config: Optional[PinchConfig] = None) -&gt; RobotHandMapper\n</code></pre> <p>Create and return a RobotHandMapper instance. If no config is provided, the default pinch mapping config is used.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>Rembrandt device ID</p> required <code>config</code> <code>Optional[PinchConfig]</code> <p>Optional custom PinchConfig</p> <code>None</code> <p>Returns:</p> Type Description <code>RobotHandMapper</code> <p>Configured RobotHandMapper instance</p>"},{"location":"api-reference/#SG_API.SG_main.get_robot_hand_mapper","title":"get_robot_hand_mapper","text":"Python<pre><code>get_robot_hand_mapper(device_id: int) -&gt; RobotHandMapper\n</code></pre> <p>Return the RobotHandMapper instance for the specified device. If no config is provided, the default pinch mapping config is used.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>Rembrandt device ID</p> required <p>Returns:</p> Type Description <code>RobotHandMapper</code> <p>Configured RobotHandMapper instance</p>"},{"location":"api-reference/#SG_API.SG_main.create_rhm_pinch_gui","title":"create_rhm_pinch_gui","text":"Python<pre><code>create_rhm_pinch_gui(device_id: int)\n</code></pre> <p>Create and register a PinchMapperGUI for the given device_id.</p>"},{"location":"api-reference/#SG_API.SG_main.get_pinch_debug_info","title":"get_pinch_debug_info","text":"Python<pre><code>get_pinch_debug_info(device_id: int)\n</code></pre> <p>Retrieve pinch-config debug info from the RobotHandMapper. Returns pinch diagnostics as dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>Rembrandt device ID</p> required"},{"location":"api-reference/#SG_API.SG_main.get_rhm_percentage_bents","title":"get_rhm_percentage_bents","text":"Python<pre><code>get_rhm_percentage_bents(device_id: int) -&gt; Tuple[Sequence[Union[int, float]], Sequence[Union[int, float]]]\n</code></pre> <p>Retrieve robot-mapped percentage flexion and abduction values (pinch mapping).</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>Rembrandt device ID</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[Sequence[Union[int, float]], Sequence[Union[int, float]]]</code> <p>(robot_flex, robot_abd)</p>"},{"location":"api-reference/#SG_API.SG_main.update_robot_hand_mapper_gui","title":"update_robot_hand_mapper_gui","text":"Python<pre><code>update_robot_hand_mapper_gui(device_id: int)\n</code></pre> <p>Update the RHM GUI</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>Rembrandt device ID</p> required"},{"location":"api-reference/#SG_API.SG_main.get_forces_sensed","title":"get_forces_sensed","text":"Python<pre><code>get_forces_sensed(device_id: int) -&gt; Sequence[Union[int, float]]\n</code></pre> <p>Returns the currently sensed forces for each finger. Use: Python<pre><code>forces = SG_main.get_forces_sensed(device_id)\n</code></pre> Can be indexed like: - <code>finger_force = forces[finger_nr]</code></p> <p>Examples: Python<pre><code>thumb_force = forces[0]  # thumb sensed force\nindex_force = forces[1]  # index finger sensed force\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_main.set_force_goals","title":"set_force_goals","text":"Python<pre><code>set_force_goals(device_id: int, force_goals: Sequence[Union[int, float]])\n</code></pre> <p>Sets force goals for each finger (thumb to ringfinger) in milliNewtons. Note: pinky has no force module</p> <p>\u26a0\ufe0f Development Status</p> <p>The resulting force on the wire might differ from the force goal requested to allow stable control. Scale up the forces if necessary. The milliNewtons is the tension in the wire pulling the finger back.</p> <p>\u26a0\ufe0f Warning for motor jitter</p> <p>Do not use <code>if contact -&gt; set force_goal to full force</code> logic, since that is not stable around the contact point. Instead, use: <code>force_goal = K * distance_to_contact</code> or another gradual function, tuning K to stability.</p> <p>Use: Python<pre><code>force_goals = [3000, 3000, 3000, 3000]  # forces in mN per finger thumb to ring. \nSG_main.set_force_goals(device_id, force_goals)\n</code></pre></p> <p>Parameters: - force_goals: List of force goals per finger</p> <p>Troubleshooting jittering: - If you notice jittering, plot your input data (easy with Teleplot extension VScode). - Check sudden force goal changes you command, improve data FPS, reduce K or in another way transition force goals more gradually.  - Note that filtering/averaging your data too much can cause delays, which can cause instable feedback loops as result!</p>"},{"location":"api-reference/#SG_API.SG_main.set_raw_vibro_data","title":"set_raw_vibro_data","text":"Python<pre><code>set_raw_vibro_data(device_id: int, vibro_data: Sequence[Sequence[int]])\n</code></pre> <p>Sets vibration data for the specified device.</p> <p>Parameters: - device_id: ID of the device - vibro_data: List of vibration data per actuator</p>"},{"location":"api-reference/#SG_API.SG_main.exit","title":"exit","text":"Python<pre><code>exit()\n</code></pre> <p>Closes all connections and cleans up resources. This is AUTOMATICALLY CALLED by the atexit module. (no need to manually call this)</p> Python<pre><code>SG_main.exit()\n</code></pre>"},{"location":"api-reference/#SG_API.SG_simulator","title":"SG_API.SG_simulator","text":"<p>SenseGlove Rembrandt Simulator Module</p> <p>This module provides glove simulation functionality for testing and development when no physical  device is connected. It simulates finger tracking data with various animation modes.</p> <p>The simulator can generate realistic finger movements for: - Static poses (STEADY_MODE) - Sine wave animations (SINE_MODE)  - Finger open/close cycles (FINGERS_OPEN_CLOSE)</p> <p>Basic Usage: Python<pre><code>import SG_API.SG_simulator as SG_sim\n\n# Create a simulated left hand with finger animation\ndevice_info = SG_T.Device_Info(device_id=123, handedness=SG_T.Hand.LEFT)\nsim = SG_sim.create_glove_sim_device(device_info, SG_sim.Simulation_Mode.FINGERS_OPEN_CLOSE)\n\n# Update simulation in your main loop\nwhile True:\n    SG_sim.update_all_glove_sims()\n    time.sleep(0.001)\n\n\n# You can then read data from SG_main like usual, but the output will be coming from the simulated glove.\n</code></pre></p> <p>Questions? Written by: - Amber Elferink Docs:    https://senseglove.gitlab.io/rembrandt/rembrandt-api/ Support: https://www.senseglove.com/support/</p>"},{"location":"api-reference/#SG_API.SG_simulator.Simulation_Mode","title":"Simulation_Mode","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of available simulation modes for the glove simulator.</p> <p>Modes: - STEADY_MODE: Static finger pose, no animation - SINE_MODE: Sine wave oscillations across all finger joints - FINGERS_OPEN_CLOSE: Smooth finger opening and closing cycles</p> <p>Examples: Python<pre><code># Set different animation modes\nSG_sim.set_mode(device_id, SG_sim.Simulation_Mode.STEADY_MODE)\nSG_sim.set_mode(device_id, SG_sim.Simulation_Mode.FINGERS_OPEN_CLOSE)\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_simulator.Glove_Simulator","title":"Glove_Simulator","text":"Python<pre><code>Glove_Simulator(device_info: Device_Info, mode)\n</code></pre> <p>Simulates a SenseGlove Rembrandt device for testing and development.</p> <p>Provides realistic finger tracking data without requiring physical hardware. Supports multiple animation modes and allows manual control of finger positions.</p> <p>Attributes:     device_id (int): Unique identifier for this simulated device     mode (Simulation_Mode): Current animation mode     running (bool): Whether simulation is active</p> <p>Examples: Python<pre><code># Create simulator with finger animation\nsim = Glove_Simulator(device_id=123, mode=Simulation_Mode.FINGERS_OPEN_CLOSE)\n\n# Update simulation in loop\nwhile sim.running:\n    sim.update()\n    time.sleep(0.001)\n</code></pre></p> <p>Initialize a new glove simulator instance.</p> <p>Args:     device_id (int): Unique device identifier for this simulator     mode (Simulation_Mode): Animation mode to use</p> <p>Examples: Python<pre><code>sim = Glove_Simulator(123, Simulation_Mode.SINE_MODE)\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_simulator.Glove_Simulator.restart","title":"restart","text":"Python<pre><code>restart()\n</code></pre> <p>Restart the simulator with current settings.</p> <p>Resets all animation timers and returns to initial finger positions.</p> <p>Examples: Python<pre><code>sim.restart()  # Reset animation to beginning\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_simulator.Glove_Simulator.stop","title":"stop","text":"Python<pre><code>stop()\n</code></pre> <p>Stop the simulator from updating.</p> <p>Sets running flag to False, preventing further animation updates.</p> <p>Examples: Python<pre><code>sim.stop()  # Stop animation\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_simulator.Glove_Simulator.update_exo_hand_angles_rad","title":"update_exo_hand_angles_rad","text":"Python<pre><code>update_exo_hand_angles_rad(exo_angles_rad: Sequence[Sequence[Union[int, float]]])\n</code></pre> <p>Update the exoskeleton joint angles in radians without changing the starting angles (which are used for base of open/close etc). So this is for calls from the update, and set_exo_rad_hand is for the user.</p> <p>Args:     exo_angles_rad (SG_T.Sequence[Sequence[Union[int, float]]]): Joint angles in radians</p>"},{"location":"api-reference/#SG_API.SG_simulator.Glove_Simulator.update","title":"update","text":"Python<pre><code>update()\n</code></pre> <p>Update the simulation for one frame. This is called automatically by update_all_glove_sims (called by SG_main.update)</p> <p>Calculates new finger positions based on the current simulation mode: - SINE_MODE: Applies sine wave oscillations to all joints - FINGERS_OPEN_CLOSE: Smooth finger opening/closing cycles - STEADY_MODE: Maintains static finger positions</p>"},{"location":"api-reference/#SG_API.SG_simulator.Glove_Simulator.set_simulation_mode","title":"set_simulation_mode","text":"Python<pre><code>set_simulation_mode(mode: Simulation_Mode)\n</code></pre> <p>Change the simulation animation mode.</p> <p>Args:     mode (Simulation_Mode): New animation mode to use</p> <p>Examples: Python<pre><code>sim.set_simulation_mode(Simulation_Mode.SINE_MODE)     # Switch to sine waves\nsim.set_simulation_mode(Simulation_Mode.STEADY_MODE)   # Switch to static pose\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_simulator.Glove_Simulator.set_exo_rad_hand","title":"set_exo_rad_hand","text":"Python<pre><code>set_exo_rad_hand(exo_rad_hand_angles: Sequence[Sequence[Union[int, float]]])\n</code></pre> <p>Set exoskeleton joint angles in radians. Also saves it to the simulation starting angles, so all simulation functions (such as open close) will be done around these initial angles.</p> <p>Args:     exo_rad_hand_angles (SG_T.Sequence[Sequence[Union[int, float]]]): Joint angles in radians</p> <p>Updates both current and starting angles for the simulation.</p> <p>Examples: Python<pre><code># Set custom finger pose\nimport numpy as np\n\nzero_angles = np.zeros((5, 8))  # 5 fingers, 8 joints each, this would be setting all exo linkages in a straight long line (not a natural pose)\n\n\nangles_rad_single_finger = np.radians(_angles_deg_single_finger) # convert to radians\nangles = np.tile(angles_rad_single_finger, (5, 1))               # create array using the the single finger angles for all fingers\n\nangles[1][2] = 0.5        # Bend index finger second joint\nsim.set_exo_rad_hand(angles)\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_simulator.Glove_Simulator.set_exo_deg_hand","title":"set_exo_deg_hand","text":"Python<pre><code>set_exo_deg_hand(exo_deg_hand_angles: Sequence[Sequence[Union[int, float]]])\n</code></pre> <p>Set exoskeleton joint angles in degrees.</p> <p>Args:     exo_deg_hand_angles (SG_T.Sequence[Sequence[Union[int, float]]]): Joint angles in degrees</p> <p>Convenience method that converts degrees to radians internally.</p> <p>Examples: Python<pre><code># Set finger pose in degrees (easier to visualize)\nimport numpy as np\nangles = np.zeros((5, 8))  # 5 fingers, 8 joints each, this would be setting all exo linkages in a straight long line (not a natural pose)\n\nangles_deg_single_finger = np.array([0, -15, 45, -90, 120, -100, 90, -50]) # this is a more natural starting pose for a single finger\nangles = np.tile(angles_deg_single_finger, (5, 1))               # create array using the the single finger angles for all fingers\nangles[1][2] = 30         # Bend index exo joint 2 30 degrees\n\nsim.set_exo_deg_hand(angles)\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_simulator.smoothstep","title":"smoothstep","text":"Python<pre><code>smoothstep(t)\n</code></pre> <p>Smooth interpolation function for easing animations.</p> <p>Args:     t (float): Input value between 0 and 1</p> <p>Returns:     float: Smoothed output value between 0 and 1</p> <p>Uses the smoothstep formula: t\u00b2 \u00d7 (3 - 2t) for smooth acceleration/deceleration.</p>"},{"location":"api-reference/#SG_API.SG_simulator.set_angles_rad","title":"set_angles_rad","text":"Python<pre><code>set_angles_rad(device_info: Device_Info, exo_angles_rad_hand: Sequence[Sequence[Union[int, float]]])\n</code></pre> <p>Set finger joint angles for a simulated device (radians).</p> <p>Args:     device_id (int): Device ID of the simulator     exo_angles_rad_hand (SG_T.Sequence[Sequence[Union[int, float]]]): Joint angles in radians</p> <p>Examples: Python<pre><code>zero_angles = np.zeros((5, 8))  # 5 fingers, 8 joints each, this would be setting all exo linkages in a straight long line (not a natural pose)\n\n\nangles_rad_single_finger = np.radians(_angles_deg_single_finger) # convert to radians\nangles = np.tile(angles_rad_single_finger, (5, 1))               # create array using the the single finger angles for all fingers\n\nangles[1][2] = 0.5        # Bend index finger second joint\n\nSG_sim.set_angles_rad(123, angles)\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_simulator.set_angles_deg","title":"set_angles_deg","text":"Python<pre><code>set_angles_deg(device_info: Device_Info, exo_angles_deg_hand: Sequence[Sequence[Union[int, float]]])\n</code></pre> <p>Set finger joint angles for a simulated device (degrees).</p> <p>Args:     device_info: DeviceInfo of the simulator     exo_angles_deg_hand (SG_T.Sequence[Sequence[Union[int, float]]]): Joint angles in degrees</p> <p>Examples: Python<pre><code># Set finger pose in degrees (easier to visualize)\nimport numpy as np\nangles = np.zeros((5, 8))  # 5 fingers, 8 joints each, this would be setting all exo linkages in a straight long line (not a natural pose)\n\nangles_deg_single_finger = np.array([0, -15, 45, -90, 120, -100, 90, -50]) # this is a more natural starting pose for a single finger\nangles = [angles_deg_single_finger.copy() for _ in range(5)]  # Create list of arrays, one per finger\nangles[1][2] = 30         # Bend index exo joint 2 30 degrees\n\nSG_main.SG_sim.set_angles_deg(SG_main.get_device_info(hand_id), angles)\nSG_sim.set_angles_deg(device_info, angles)\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_simulator.create_glove_sim_device","title":"create_glove_sim_device","text":"Python<pre><code>create_glove_sim_device(device_info: Device_Info, mode: Simulation_Mode) -&gt; Glove_Simulator\n</code></pre> <p>Create a glove simulator that integrates with the main API system.</p> <p>Args:     device_info (SG_T.Device_Info): Device information (device_id, handedness, etc.)     mode (Simulation_Mode): Animation mode to use</p> <p>Returns:     Optional[Glove_Simulator]: The created simulator instance, or None if validation fails</p> <p>This function creates a simulator and properly registers it with the callback  system so it appears as a connected device to the main API.</p> <p>Examples: Python<pre><code># Create left hand simulator that integrates with SG_main functions\ndevice_info = SG_T.Device_Info(device_id=123, handedness=SG_T.Hand.LEFT)\nsim = SG_sim.create_glove_sim_device(device_info, SG_sim.Simulation_Mode.SINE_MODE)\n\n# Now you can use normal API functions\nangles = SG_main.get_exo_angles_rad(123)\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_simulator.stop_all_glove_sims","title":"stop_all_glove_sims","text":"Python<pre><code>stop_all_glove_sims()\n</code></pre> <p>Stop all active glove simulators.</p> <p>Calls stop() on every simulator, preventing further updates. Useful for clean shutdown of all simulations.</p> <p>Examples: Python<pre><code># Stop all simulators when exiting application\nSG_sim.stop_all_glove_sims()\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_simulator.get_sim","title":"get_sim","text":"Python<pre><code>get_sim(device_id: int)\n</code></pre> <p>Get the simulator instance for a specific device ID.</p> <p>Args:     device_id (int): Device ID of the simulator to retrieve</p> <p>Returns:     Glove_Simulator: The simulator instance</p> <p>Examples: Python<pre><code>sim = SG_sim.get_sim(123)\nsim.set_simulation_mode(SG_sim.Simulation_Mode.STEADY_MODE)\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_simulator.update_all_glove_sims","title":"update_all_glove_sims","text":"Python<pre><code>update_all_glove_sims()\n</code></pre> <p>Update all active glove simulators for one frame.</p> <p>Call this continuously in your main loop to keep all simulations running. Should be called at ~1kHz for smooth animation.</p> <p>Examples: Python<pre><code># Main simulation loop\nwhile True:\n    SG_sim.update_all_glove_sims()\n    time.sleep(0.001)  # ~1kHz\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_simulator.set_mode","title":"set_mode","text":"Python<pre><code>set_mode(device_id: int, mode: Simulation_Mode)\n</code></pre> <p>Change the animation mode for a specific simulator.</p> <p>Args:     device_id (int): Device ID of the simulator     mode (Simulation_Mode): New animation mode to use</p> <p>Examples: Python<pre><code># Switch to different animation modes\nSG_sim.set_mode(123, SG_sim.Simulation_Mode.SINE_MODE)\nSG_sim.set_mode(123, SG_sim.Simulation_Mode.FINGERS_OPEN_CLOSE)\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_simulator.is_exo_angles_type","title":"is_exo_angles_type","text":"Python<pre><code>is_exo_angles_type(obj) -&gt; bool\n</code></pre> <p>Check if an object is of type Sequence[Sequence[Union[int, float]]] AKA Union[List[List[float]], List[List[int]], List[np_array_type]]</p>"},{"location":"api-reference/#SG_API.SG_simulator.set_simulation_fn","title":"set_simulation_fn","text":"Python<pre><code>set_simulation_fn(device_id: int, update_fn: Callable[[float], Sequence[Sequence[Union[int, float]]]])\n</code></pre> <p>Set the custom update function for angles for a specific simulator, when CUSTOM_FUNCTION mode is enabled.</p> <p>Args:     device_id (int): Device ID of the simulator     update_fn (Simulation_Mode): Function to call. Should have signature myFunction(t: float) and must return Sequence[Sequence[Union[int, float]]] containing 8 angles per finger.</p> <p>Examples: Python<pre><code>_angles_deg_single_finger = np.array([0, -15, 45, -90, 120, -100, 90, 90]) \n_angles_rad_single_finger = np.radians(_angles_deg_single_finger)\n_starting_angles_rad_hand = np.tile(_angles_rad_single_finger, (5, 1))\n\ndef test_custom_fn(t : float) -&gt; SG_T.Sequence[Sequence[Union[int, float]]]:\n    realT = t * 50\n    MIN_ANGLE_RAD = math.radians(75)  # Set your minimum angle (e.g., 10\u00b0)\n    MAX_ANGLE_RAD = math.radians(90)  # Set your maximum angle (e.g., 60\u00b0)\n    t_normalized = 0.5 * (1 - math.cos(2 * math.pi * realT))  \n    angle = MIN_ANGLE_RAD + SG_simulator.smoothstep(t_normalized) * (MAX_ANGLE_RAD - MIN_ANGLE_RAD)\n    return _starting_angles_rad_hand + np.cos(angle)\n\nSG_main.SG_sim.set_simulation_fn(hand_id, test_custom_fn)\n</code></pre></p>"},{"location":"api-reference/#SG_API.SG_types","title":"SG_API.SG_types","text":"<p>Contains all types used throughout the whole API.</p> <p>Questions? Written by: - Amber Elferink Docs:    https://senseglove.gitlab.io/rembrandt/rembrandt-api/ Support: https://www.senseglove.com/support/</p>"},{"location":"api-reference/#SG_API.SG_types.Vec3_type","title":"Vec3_type  <code>module-attribute</code>","text":"Python<pre><code>Vec3_type = Sequence[Union[int, float]]\n</code></pre> <p>List, tuple, or np array of 3 numbers: x, y, z</p>"},{"location":"api-reference/#SG_API.SG_types.Quat_type","title":"Quat_type  <code>module-attribute</code>","text":"Python<pre><code>Quat_type = Sequence[Union[int, float]]\n</code></pre> <p>List, tuple, or np array of 4 numbers: w, x, y, z</p>"},{"location":"api-reference/#SG_API.SG_types.Control_Mode","title":"Control_Mode","text":"<p>               Bases: <code>IntEnum</code></p>"},{"location":"api-reference/#SG_API.SG_types.Control_Mode.FORCE_GOAL_DEFAULT","title":"FORCE_GOAL_DEFAULT  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>FORCE_GOAL_DEFAULT = 0\n</code></pre> <p>This is the default mode. The motors will try to reach the force goal set. Set the force goal to 0 to move freely.</p>"},{"location":"api-reference/#SG_API.SG_types.Control_Mode.OFF","title":"OFF  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>OFF = 9999\n</code></pre> <p>Motors will fully turn off, so also not move with your finger</p>"},{"location":"api-reference/#SG_API.SG_types.Control_Mode.CALIBRATE_TRACKING_NEVER_EVER_USE","title":"CALIBRATE_TRACKING_NEVER_EVER_USE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>CALIBRATE_TRACKING_NEVER_EVER_USE = 42666\n</code></pre> <p>DON'T EVER SEND THIS TO THE GLOVE, it will reset tracking offset angles. It will ruin it the glove for good and requires customer support to fix it.</p>"},{"location":"api-reference/#SG_API.SG_types.Thimble_dims","title":"Thimble_dims  <code>dataclass</code>","text":"Python<pre><code>Thimble_dims(sphere_center_pos: Vec3_type, rot: Quat_type, radius: float, cylinder_center_pos: Vec3_type, cylinder_length: float)\n</code></pre> <p>To draw the users fingertip thimble, we use a sphere and a cilinder. These are the dimensions of the sphere and cilinder.</p>"},{"location":"control/","title":"Control","text":""},{"location":"control/#force-control","title":"Force control","text":"<p>Internally within the glove, a force controller runs much faster than 1khz to set the tension on the wire to the specified force by rotating the motor. </p> <p>set_force_goals() accepts a list with one force goal per finger (in milliNewtons) and is sent to the glove, which will from then on be the new force goals. When the force is set to 0, it keeps a minimal tension of ~80 grams (=800 mN) on the wire to prevent it from getting slack, allowing the finger to move as free as possible.</p> <p>The max force the glove can actively pull is around 3500 mN. If the user presses harder than that, the motor acts as a brake up to ~20000 mN.</p> <p>Notes: </p> <ul> <li>The final force on the wire might differ from the force goal requested to allow stable control. Scale up the forces if necessary.</li> <li>The milliNewtons are the tension in the wire pulling the finger back.</li> <li>The pinky does not have a force feedback motor, so is not controllable.</li> </ul>"},{"location":"fps-performance/","title":"Why is my glove force jittering? Tips to improve it","text":"<p>Active haptic feedback (motorized feedback) of the glove works by getting the tracking data, then sending a force back to the glove based on that tracking data. Now there will always be a tiny bit of delay between those. If that delay becomes larger than a few ms, you get the problem where the force isn't engaged fast enough to respond to the movements, and that will result in instability (jittering), usually on/near contact.</p> <p>You can fix this in a couple of ways.</p> <ol> <li>First, make sure your commanded forces look smooth over time. You can use Teleplot (VScode extension) to quickly plot this. </li> </ol> <p>If not, be careful with filtering for latency. Plot the filtered in one plot with the original signal so you can see the caused latency. Latency can also cause instability, so keep it to a minimum.</p> <p>If the input smooth, some further options:</p> <ul> <li>Increasing the FPS (frames/second) of the data and reducing the latency between the glove's position update given and force received. </li> <li>Lower the forces</li> <li>Reduce how quickly the force responds (for example with a low pass filter, dampening, or a controller on top). This will smooth the signal and cause a more gradual buildup/reduction of force.</li> </ul> <p>Fixing this with the third option might cause: - A solid surface to feel more squishy instead of solid. (Due to less sudden force changes.) - Less transparency on no forces (meaning how much you feel the force when there should be no force at all).</p>"},{"location":"fps-performance/#how-to-measure-data-rates","title":"How to measure data rates","text":""},{"location":"fps-performance/#fps-frames-per-second","title":"FPS (frames per second)","text":"<p>Our API logs the update rate to the log files. So you can check those in <code>Rembrandt_API/logs/</code>. Or alternatively, use the SG_FPS script to quickly log your FPS at a certain point in your code. Python<pre><code>from SG_API import SG_FPS\n\nfps_my_function = SG_FPS.FPSCounter(1.0, \"my_function\")\n\ndef my_function():\n    global fps_my_function\n    fps_my_function.update() #updates, and every 1.0 seconds prints my_function FPS\n</code></pre></p>"},{"location":"fps-performance/#what-works-to-keep-glove-data-1khz","title":"What works to keep glove data &gt;1kHz.","text":""},{"location":"fps-performance/#our-data-uses-1khz-callbacks-but-your-code-can-slow-it-down","title":"Our data uses &gt;1kHz callbacks, but your code can slow it down!","text":"<p>Data in our API comes in through callbacks when new data is received. These are fast, but only if your program doesn't steal their processing time!</p>"},{"location":"fps-performance/#dont-use-busy-while-loops","title":"Don't use busy while loops","text":"<p>Python<pre><code>while(True)\n    #do something, or nothing\n    pass\n</code></pre> This is a busy while loop. While it looks like it shouldn't do anything, this eats up all CPU power of the program, meaning the callbacks of the data will no longer be called at 1kHz. It can get as bad as only receiving data at 50 Hz.</p> <p>Python<pre><code>import time\n\nwhile(True)\n    #do something, or nothing\n    time.sleep(1) # sleep 1 second\n    pass\n</code></pre> This is a non-busy while loop. During this sleep time other parts of the program are allowed to execute, such as the data callbacks needed at 1kHz. Don't reduce this sleep time too much or it will become a more and more busy while loop.</p> <p>We recommend instead of using a while loop yourself, to use <code>SG_main.keep_program_running()</code>. This internally uses this while loop system to keep the program alive, but also allows closing down smoothly with Ctrl+C, and still allow high data callbacks.</p>"},{"location":"fps-performance/#making-things-faster-in-python","title":"Making things faster in python","text":"<p>We recommend VTune by Intel to profile your code to find the parts taking the longest. </p>"},{"location":"fps-performance/#threading-vs-multiprocessing-should-you-use-it","title":"Threading vs multiprocessing, should you use it?","text":"<p>Threading in python works very different from in other programs. Even with threading, only one block of python can run at a time, so it is not parallel. However, I/O or C++ calls can run simultaneously with a python thread. So good for C++/file writing, but for pure python nothing will actually run in parallel, only sequential, AND it add an overhead, so is often slower.</p> <p>Multiprocessing in python is true parallelism, but harder to implement, and a lot of overhead on making the actual threads.</p>"},{"location":"fps-performance/#dont-put-too-much-processing-in-the-new_data_callback","title":"Don't put too much processing in the new_data_callback","text":"<p>If you do, that obviously causes it to be slower, and the callback not to be called often enough. So improve your code performance by profiling if that's an issue. What helped for us it to move computationally heavy things to CPP and call them from python.</p>"},{"location":"fps-performance/#print-can-reduce-fps","title":"print() can reduce fps","text":"<p>Don't call them continuously in the main update loop, only print every few seconds.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#supported-os","title":"Supported OS:","text":"<ul> <li>Windows</li> <li>Linux Ubuntu &gt;= 20.04, and other Linux systems with &gt;= GCC 9 </li> </ul>"},{"location":"getting_started/#supported-python-versions-currently","title":"Supported python versions (currently)","text":"<ul> <li>python 3.8</li> <li>python 3.12</li> </ul> <p>We recommend anaconda to install these to manage multiple versions (now or in the future) easily.</p> <p>If you require a different version &gt;3.8, we can support it by recompiling the library. Send us a message if required.</p>"},{"location":"getting_started/#installation","title":"Installation","text":""},{"location":"getting_started/#required-softwaredrivers","title":"Required Software/drivers:","text":""},{"location":"getting_started/#windows","title":"Windows","text":"<p>For Windows, install the WinUSB driver: Zadig. Linux does not require a driver.    * Opening this, with the glove plugged in, Select R1 (Composite Parent) in the dropdown. Don't change any other settings. Click Install Driver.</p>"},{"location":"getting_started/#linux","title":"Linux","text":"<p>To allow non-root access to the Rembrandt device over USB, you need to add a custom udev rule. 1. Create a new rule file:</p> Text Only<pre><code>    sudo nano /etc/udev/rules.d/99-rembrandt.rules\n</code></pre> <ol> <li> <p>Paste the following:</p> Text Only<pre><code>SUBSYSTEM==\"usb\", ATTR{idVendor}==\"2e8a\", ATTR{idProduct}==\"10f3\", MODE=\"0666\"\n</code></pre> </li> <li> <p>Reload &amp; Apply:</p> Text Only<pre><code>sudo udevadm control --reload-rules &amp;&amp; sudo udevadm trigger\n</code></pre> </li> </ol>"},{"location":"getting_started/#setup","title":"Setup","text":"<p>See Troubleshooting for common errors and issues. * Install python 3.8.x or python 3.12. Use Python or Anaconda (virtual env manager for python, allowing multiple python versions on one pc).  *  Clone the Repository Bash<pre><code>git clone https://gitlab.com/senseglove/rembrandt-api/\n</code></pre>    You can clone this to a subfolder of your project, or run examples directly from the provided API. * Install python packages * Set your python interpreter to your python environment (VScode: Ctrl+Shift+P &gt; Python interpreter).  1. In terminal, navigate to the parent directory of <code>SG_API</code> (where the setup.py file is).     Bash<pre><code>cd Rembrandt-API\n</code></pre></p> <ol> <li> <p>Run pip install. Make sure it uses the python version from your anaconda environment.</p> <p>Example for Windows anaconda (replace your environment).  Text Only<pre><code>%USERPROFILE%/anaconda3/envs/yourEnvironment/python.exe -m pip install -e .\n</code></pre></p> <p>If normal python (no anaconda): Bash<pre><code>    pip install -e .\n</code></pre></p> <p>Similar for Linux, <code>conda activate yourenv</code> before running <code>pip install -e .</code>, or alternatively use the python path of your environment with the <code>your/path/to/python -m pip install -e .</code></p> </li> </ol>"},{"location":"getting_started/#examples-quick-start","title":"Examples / Quick start","text":"<p>PLEASE READ THIS SECTION ENTIRELY BEFORE STARTING</p> <p>This section walks you through the most important features of the script <code>main_example.py</code> which is a script using the main features of the API, as you would in your project. You can find this and more in the <code>examples</code> folder. </p>"},{"location":"getting_started/#switch-between-simulated-and-real-glove","title":"Switch between Simulated and Real glove","text":"<p>You can develop even without a physical glove. For that, use the following init: Python<pre><code>from SG_API import SG_main, SG_types as SG_T \n\ndevice_ids = SG_main.init(1, SG_T.Com_type.SIMULATED_GLOVE)\n</code></pre> This will start a steady simulated glove, which you can set to continually open/close, or set to steady (see main_example.py).  For in depth simulated glove functions see Simulated Glove</p> <p>For using an actual glove, change SIMULATED_GLOVE to REAL_GLOVE_USB : Python<pre><code>device_ids = SG_main.init(1, SG_T.Com_type.REAL_GLOVE_USB)\n</code></pre></p>"},{"location":"getting_started/#on-new-data-callback","title":"On new data callback","text":"<p>The on_new_data callback fires when the glove has updated the data in the API, such as tracking or force data. <code>SG_main</code> contains all functions you need. Some commonly needed functions are given here.</p> Python<pre><code>    def on_new_data(from_device_id):\n        if from_device_id == hand_id:\n            exo_poss, exo_rots = SG_main.get_exo_joints_poss_rots(hand_id)\n            gui.update_hand_exo(exo_poss)\n\n            fingertips_poss, fingertips_rots = SG_main.get_fingertips_pos_rot(hand_id)\n\n            flexion_perc_bents, abduction_perc_bents = SG_main.get_percentage_bents(hand_id)\n\n            forces = simulate_forces()\n            SG_main.set_force_goals(hand_id, forces)\n\n    SG_main.add_rembrandt_data_callback(on_new_data)\n</code></pre> <p>\u26a0\ufe0f Important Note</p> <p>Keep what is in the new_data callback as brief as possible (preferably just copying the data). Heavy calculations will drop the 1kHz framerate required for crisp haptic feedback. For more info see Performance.</p>"},{"location":"getting_started/#keep-the-script-running","title":"Keep the script running","text":"<p>The data callback will automatically update with new data at 1khz, but only if the file is still running. To do this, call: Python<pre><code>    SG_main.keep_program_running()\n    # after this will not execute. It blocks until stopping the program. \n    # Ctrl+C or a command closing python stops it.\n</code></pre></p> <p>Alternatively, you can replace SG_main.keep_program_running() with this to run your own while loop with: Python<pre><code>    try:\n        while SG_main.SG_cb.running:\n            time.sleep(1)  # This loop does not do anything but keep the program alive. Some sleep is important to not eat all CPU capacity.\n    except: \n        pass # important errors will still log. This try/except just ignores the keyboard interrupt error on Ctrl+C.\n</code></pre></p> <p>You can call functions such as <code>SG_main.get_fingertips_pos_rot(hand_id)</code> or <code>SG_main.set_force_goals()</code> in your own while loop instead of the <code>on_new_data</code> callback. This will retrieve the latest tracking data available, and when the callback loop ends internally, send the latest data in force goals to the glove. The callback <code>on_new_data</code> is purely a method to only update when new glove data is available.</p> <p>\u26a0\ufe0f Important Note</p> <p>You must use sleep in the while loop, or your loop can eat up all CPU space which the callback needs to give data at 1kHz, important for good force feedback! For more info, see: Performance.</p>"},{"location":"getting_started/#hover-to-get-docs-in-code","title":"Hover to get Docs in code","text":"<p><code>SG_main</code> will contain most of what you need. Don't forget that you can always hover on a function to see how to use it (in Vscode at least), or check the API Docs.  </p>"},{"location":"getting_started/#examples","title":"Examples","text":""},{"location":"getting_started/#main_examplepy","title":"main_example.py","text":"<p>Running <code>examples/main_example.py</code> should give you a screen like this, showing the top view of the exoskeleton of the glove in real time (or simulated glove). The blue dots are the fingertip positions, and the linkages of the exoskeleton are white. The axes are drawn at the origin of the glove.</p> <p>Press the right mouse button and drag to rotate.</p> <p> </p> <p>Additionally, forces can be turned on that apply to all fingers in gradual sine waves, minimal force, to maximal force, and back to minimal repeatedly.</p>"},{"location":"getting_started/#record_glovepy-and-play_recordingpy","title":"record_glove.py and play_recording.py","text":"<p>Aside from simulation, you play back captured motions as if the glove were connected, and also record your own. Currently this only records and plays back the tracking, and not forces.</p> <p>You can record from any script using the following: Python<pre><code>    print(\"Recording glove data for 10 seconds...\")\n    SG_recorder.record_glove_data(hand_id, 10.0, \"myrecording.json\")\n</code></pre> You can find this file in the <code>recordings/</code> folder. Recording again will overwrite it. You can play that recording back with: Python<pre><code>    print(\"Playing back recording...\")\n    SG_recorder.play_recording(hand_id, \"myrecording.json\")\n</code></pre> This will simulate the glove with these motions, so actually output all data you would expect via the API. There are existing recordings to work with in the recordings folder.</p>"},{"location":"getting_started/#tracking-and-control","title":"Tracking and Control","text":"<p>The types of tracking data are explained in Tracking. Force feedback is explained in Control.</p>"},{"location":"getting_started/#convenience-tip","title":"Convenience tip:","text":"<p>In .vscode / launch.json you can set \"program\": \"${workspaceFolder}/your_file.py\", and press F5 to play that script no matter the file you have open.</p>"},{"location":"getting_started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting_started/#libusb-initialization-error","title":"Libusb initialization error","text":"<p>Text Only<pre><code>Error: 2025-03-25 13:49:40.316 (   1.394s) [DataRetrievalLoo]    RembrandtDevice.cpp:1016  INFO| Initializing libusb device handle... - { VID: dead, PID: 1606, BN: 2, PN: 2, DA: 14 }\n2025-03-25 13:49:40.316 (   1.394s) [DataRetrievalLoo]    RembrandtDevice.cpp:1024   ERR| Failed to initialize libusb device handle: Entity not found - { VID: dead, PID: 1606, BN: 2, PN: 2, DA: 14 }\n</code></pre> This happens on Windows when you did not install the driver! See Required Software/Drivers above.</p>"},{"location":"getting_started/#filenotfounderror-so-or-dll","title":"FileNotFoundError .so or .dll:","text":"Text Only<pre><code>FileNotFoundError: Could not find module 'C:\\Users\\&lt;username&gt;\\anaconda3\\envs\\&lt;yourenv&gt;\\lib\\site-packages\\SG_API\\CPPlibs\\libSG_math.dll' or `libSG_math.so` (or one of its dependencies). Try using the full path with constructor syntax.\n</code></pre> <p>This means that <code>pip install .</code> did not work correctly. Please try that again and make sure you use the correct python to call it. When in doubt, pip install using the python.exe similar to <code>C:/Users/yourUserName/anaconda3/envs/yourEnvironmentName/python.exe -m pip install -e .</code> (In some cases it may be pip3.) Then double check your interpreter in vscode to use the correct one (Ctrl+Shift+P -&gt; Python interpreter). </p>"},{"location":"getting_started/#type-errors","title":"Type errors","text":"<p>You might get yellow bars with errors similar to:</p> <p></p> <p>If your arrays have the correct shape, it should work when you actually run it. The warning is there because while numpy arrays can be used interchangeably with python arrays, the typing intellisense does not see they are compatible. You can ignore warnings like these as long as your array shape is correct.</p> <p>Sequence[Sequence[int | float]] means it expects either a nested list or numpy array of shape: List[List[int or float]]. You can check SG_types (in the API_reference, or in the actual file) to check what is expected inside.</p>"},{"location":"getting_started/#running-scripts-is-disabled-on-this-system","title":"running scripts is disabled on this system","text":"<p>Text Only<pre><code>anaconda3\\shell\\condabin\\conda-hook.ps1 cannot be loaded because running scripts is disabled on this system.\n</code></pre> This occurs sometimes on windows. To fix: Open Powershell with admin rights (right click) and run: <code>Set-ExecutionPolicy Unrestricted</code></p>"},{"location":"getting_started/#is-my-glove-connected","title":"Is my glove connected?","text":""},{"location":"getting_started/#windows_1","title":"Windows","text":"<p>Expected behavior in Windows Device Manager &gt; Universal Serial Bus Devices:  Once you plug in the device, you should see 2x Rembrandt showing up per glove (2 channels per glove).</p> <p>If this is the case, the code should be able to connect. Make sure on Windows (not required for Linux), you also installed the driver with Zadig (see Required Software/drivers).</p>"},{"location":"releases/","title":"Releases","text":""},{"location":"releases/#v00","title":"v0.0","text":""},{"location":"releases/#v0014","title":"v0.0.14","text":"<p>Minor changes to the</p>"},{"location":"releases/#v0013","title":"v0.0.13","text":"<p>Github pages update</p>"},{"location":"releases/#v0012","title":"v0.0.12","text":"<p>Docs and docs for releases update.</p>"},{"location":"releases/#v0011","title":"v0.0.11","text":"<p>Addition of Github pages for docs.</p>"},{"location":"releases/#v0010","title":"v0.0.10","text":"<p>First formal release of the R1 API going to customers with license on Github.</p>"},{"location":"releases/#v009","title":"v0.0.9","text":"<p>First formal release of the R1 API going to customers.</p>"},{"location":"robot_hand_mapper/","title":"Robot hand percentage bent mapper","text":"<p><code>examples/Robot_hand_mapper_pbent.py</code> is an example where you can map percentage bents to accurate pinches on the robot hand when the glove pinches. </p> <ul> <li>When not pinching it will use the default percentage bent values of the glove.</li> <li>When approaching a pinch, the percentage bent values from the glove (green) will be gradually mapped to the saved robot hand values when the glove detects pinching for a specific finger.</li> </ul> <p>Create a config similar to the seed hand config with values the robot hand takes for each pinch. </p> <p>The robot_hand_mapper_pbent.py has a GUI that shows the updated mapping considering pinches as orange bars.</p> <p></p> <p>In the image you can see the index + thumb are pinching, and only that value (orange) is adjusted to map to a robot hand pinch.</p> <p>The config must contain the values going out to the robot hand. You can use the button below each finger to save that current number to a config file, using also the Save config button at the bottom. Note that the robot hand (so not your glove)  should be making the pinches when pressing the button. In the end, via GUI buttons or not, the saved config file must contain the inputs going into the robot hand that result in a robot hand pinch.</p> <p>After loading that config, the orange values retreived with <code>robot_flex, robot_abd = SG_main.get_rhm_percentage_bents(hand_id)</code> should give you accurate pinches.</p> <p>Currently we only provide this solution for 1DOF robot finger control via percentage bent.  To learn how to adjust percentage bents and how they work, see Tracking.</p>"},{"location":"simulated_glove/","title":"Simulated glove","text":""},{"location":"simulated_glove/#creating-a-simulated-glove","title":"Creating a simulated glove","text":"<p>A left and right simulated glove can automatically be created if init is set to  Python<pre><code>    device_ids = SG_main.init(1, SG_T.Com_type.SIMULATED_GLOVE) \n</code></pre> If SG_main.init(2, ...) is called, a left simulated glove will be created additionally automatically.</p> <p>If a simulated glove is desired next to a real one, (or simulating a third glove), you can also create one manually with: Python<pre><code>    SG_main.init_rembrandt_sim(SG_T.Hand.RIGHT, SG_main.SG_sim.Simulation_Mode.FINGERS_OPEN_CLOSE)\n</code></pre></p> <p>After creation, more specialized simulated glove functions can be accessed by getting the simulator. Text Only<pre><code>    simulator = SG_main.SG_simulated_glove.get_sim(device_id)\n</code></pre></p>"},{"location":"simulated_glove/#simulate-tracking","title":"Simulate Tracking","text":""},{"location":"simulated_glove/#default-functions","title":"Default functions","text":"<p>Are adjustable with the parameter init or the  <code>SG_main.SG_sim.set_mode()</code> function.</p> <p>Creates a non moving exoskeleton. Python<pre><code>    device_ids = SG_main.init(1, SG_T.Com_type.SIMULATED_GLOVE, SG_main.SG_sim.Simulation_Mode.STEADY_MODE) \n</code></pre></p> <p>Creates fingers that gradually open and close. Python<pre><code>    device_ids = SG_main.init(1, SG_T.Com_type.SIMULATED_GLOVE, SG_main.SG_sim.Simulation_Mode.FINGERS_OPEN_CLOSE) \n</code></pre></p> <p>Creates fingers where the angles are set by a pure sine. Python<pre><code>    device_ids = SG_main.init(1, SG_T.Com_type.SIMULATED_GLOVE, SG_main.SG_sim.Simulation_Mode.SINE_MODE) \n</code></pre> or, after the init for any simulator: Python<pre><code>    SG_main.SG_sim.set_mode(hand_id, SG_main.SG_sim.Simulation_Mode.CUSTOM_FUNCTION)\n</code></pre></p>"},{"location":"simulated_glove/#custom-angles","title":"Custom angles","text":"<p>To change the starting angles, you can use: Python<pre><code>         # sets splay to 1 degree, and 2nd and last flexion joint to 90 degrees for all fingers.\n\n        angles_deg_single_finger = np.array([1, 0, 90, 0, 0, 0, 0, 90])\n        angles = [angles_deg_single_finger.copy() for _ in range(5)] \n        SG_main.SG_sim.set_angles_deg(SG_main.get_device_info(hand_id), angles)\n</code></pre> Or alternatively: Python<pre><code>   # sets the last flexion angle to 90, meaning the exoskeleton is completely straight with fingertips pointing forwards.\n\n   angles_rad =                       [\n            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.5707963267948966],\n            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.5707963267948966],\n            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.5707963267948966],\n            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.5707963267948966],\n            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.5707963267948966]\n        ]\n        SG_main.SG_sim.set_angles_rad(SG_main.get_device_info(hand_id), angles_rad)\n</code></pre></p>"},{"location":"simulated_glove/#play-glove-recording","title":"Play glove recording","text":"<p>See <code>examples/play_recording.py</code> for an example. We have pre existing recordings of opening and closing each finger and pinching. You can also record your own recording with <code>examples/record_glove.py</code>.</p> <p>Python<pre><code>    SG_main.init(0, SG_T.Com_type.SIMULATED_GLOVE)\n\n    recording_filename = \"close_each_finger.json\"\n\n    recording_device_info = SG_recorder.get_device_info(recording_filename)\n    simulator = SG_main.init_rembrandt_sim(recording_device_info.hand, SG_main.SG_sim.Simulation_Mode.STEADY_MODE)\n\n    hand_id = simulator.device_id\n\n\n    exo_poss, rots = SG_main.get_exo_joints_poss_rots(hand_id)\n    gui.create_hand_exo(exo_poss)\n\n\n    SG_recorder.play_recording(simulator.device_info, recording_filename, loop=True)\n</code></pre> The callback will now update the angles internally, and fingertips etc can be obtained in the loop or on_new_data as usual.</p>"},{"location":"simulated_glove/#custom-function-to-adjust-the-angles","title":"Custom function to adjust the angles","text":"<p>To move the exoskeleton in a way you like, you can set a custom function for it to execute to change the angles.</p> <p>Python<pre><code>_angles_deg_single_finger = np.array([0, -15, 45, -90, 120, -100, 90, 90]) \n_angles_rad_single_finger = np.radians(_angles_deg_single_finger)\n_starting_angles_rad_hand = np.tile(_angles_rad_single_finger, (5, 1))\n\n## allows you to set custom angles for the simulation\ndef test_custom_fn(time : float) -&gt; SG_T.Sequence[Sequence[Union[int, float]]]:\n\n   # your function to adjust the exo angles\n   realT = time * 50\n   MIN_ANGLE_RAD = math.radians(75)  # Set your minimum angle (e.g., 10\u00b0)\n   MAX_ANGLE_RAD = math.radians(90)  # Set your maximum angle (e.g., 60\u00b0)\n   t_normalized = 0.5 * (1 - math.cos(2 * math.pi * realT))  \n   angle = MIN_ANGLE_RAD + SG_simulator.smoothstep(t_normalized) * (MAX_ANGLE_RAD - MIN_ANGLE_RAD)\n\n\n   return _starting_angles_rad_hand + np.cos(angle)\n\n\n\ntry: \n    device_ids = SG_main.init(1, SG_T.Com_type.SIMULATED_GLOVE, SG_main.SG_sim.Simulation_Mode.STEADY_MODE) \n    hand_id = device_ids[0]\n\n    SG_main.SG_sim.set_simulation_fn(hand_id,  test_custom_fn)\n    SG_main.SG_sim.set_mode(hand_id, SG_main.SG_sim.Simulation_Mode.CUSTOM_FUNCTION)\n\n\n# below go your default on_new_data or loops similar to main_example.py. \n</code></pre> You can find a working example in <code>internal_dev_scripts/custom_simulation_example.py</code>.</p>"},{"location":"tracking/","title":"Tracking","text":"<p>The API supports a few different representations of glove tracking data: </p> <ul> <li>Fingertip positions / rotations</li> <li>Percentage bent of the fingers</li> <li>Raw exoskeleton data</li> </ul>"},{"location":"tracking/#coordinate-system","title":"Coordinate system","text":"<p>We use the following coordinate system:   When the wrist rotation is 0, 0, 0, the following is true:</p> <ul> <li> <p>The X-Axis runs parallel with the stretched fingers, running roughly from the wrist joint to the middle finger MCP joint.</p> </li> <li> <p>The Y-Axis runs along the MCP joints. For right hands, the positive direction is from pinky MCP to index finger MCP. For left hands, the positive direction is from index MCP to the index finger MCP.</p> </li> <li> <p>The Z-Axis points 'up' from the hand palm. The positive direction is from the palm of the hand to the back of the hand.</p> </li> <li> <p>Our left- and right hands share the same 'forward' and 'upward' directions. The difference in positive y-direction between left- and right hands means that finger flexion also shares the same positive / negative direction between the hands.</p> </li> </ul>"},{"location":"tracking/#origin-of-the-glove-000","title":"Origin of the glove (0,0,0)","text":"<p>The 0.4 will have a dot just above the version number printed. For the 0.3 this is the same point but not visual on the prototype. In prototype 0.2, this has been a screw near the thumb base. </p>"},{"location":"tracking/#fingertip-positions-rotations","title":"Fingertip positions, rotations","text":"<p>get_fingertips_pos_rot() gets the position (vec3) and rotation (quaternion) of each fingertip. The red point indicates this tip. </p> <p> </p> <p>This can be adjusted by changing FINGERTIP_OFFSET and FINGERTIP_OFFSET_ROT variable for the respective exoskeleton type within <code>SG_API.exo_dimensions</code>, which hold the offsets with respect to the final exoskeleton position/rotation. TODO: make this a user function.</p>"},{"location":"tracking/#todo-fingertip-distances","title":"TODO: Fingertip distances","text":""},{"location":"tracking/#percentage-bent","title":"Percentage bent","text":"<p>Percentage bent can be retrieved with the function get_percentage_bents(). This returns <code>flexion_perc_bents</code> and <code>abduction_perc_bents</code>. Each is an array with as length of the number of fingers.</p> <ul> <li> <p><code>flexion_perc_bents</code>: </p> <ul> <li>All fingers: 0 (open) to 10000 (closed)</li> </ul> </li> <li> <p><code>abduction_perc_bents</code>: </p> <ul> <li>Thumb: <ul> <li>0 \u2192 thumb is in plane with the palm</li> <li>10000 \u2192 thumb is not aligned with handpalm, but radially extended maximally</li> </ul> </li> <li>Fingers:<ul> <li>0 \u2192 splay to the left</li> <li>10000 \u2192 splay to the right </li> <li>5000 \u2192 in the middle</li> </ul> </li> </ul> </li> </ul>"},{"location":"tracking/#how-percentage-bent-is-calculated","title":"How percentage bent is calculated","text":"<p>The percentage bent calculations uses the orientations of the fingertips to determine how bent the fingers are. </p> <p></p> <p>The orientations of these arrows are used. We calculate these by adding up the exoskeleton flexion angles for flexion percentage bent, and use the single abduction sensor for abduction percentage bent. This is then normalized between 0 and 10000 normalized based on a pre-set open and closed finger value.  The left hand on the image would give 0, the middle around 7000 and the right one around 4000 in default settings. We use this algorithm because it is independent of different hand sizes.</p>"},{"location":"tracking/#adjusting-the-minmax-bent-settings","title":"Adjusting the min/max bent settings:","text":"<p>flex_angles and abd_angles can be obtained from <code>SG_main.get_raw_percentage_bent_angles()</code>. These are the raw angles the percentage bent calculations are based on, and is \u03b2 in the image.</p> <p>The min/max ranges of these angles were determined experimentally. These can be changed by overwriting the default values with <code>SG_main.set_percentage_bent_vars()</code>. </p>"},{"location":"tracking/#todo-gripper-open-close","title":"TODO: Gripper open close","text":"<p>This function will map the movement of the index and thumb to a gripper open (0) and gripper closed (10000) value.</p>"},{"location":"tracking/#raw-exoskeleton-data","title":"Raw exoskeleton data","text":""},{"location":"tracking/#exo-positions-rotations","title":"Exo positions rotations","text":"<p>get_exo_joints_poss_rots() returns the positions (vec3) and rotations (quaternion) of each joint in the exoskeleton with respect to the hub origin. These are indexible like <code>[finger_nr][exo_joint_nr]</code>. The image shows the position locations, and the orientation when multiplying the quaternion with [1,0,0].</p> <p> </p> <p>For flexion joints, the position is the center of each joint. For the first joint (splay), it is on the axis of the splay rotation, with the z of the first flexion joint. </p>"},{"location":"tracking/#exo-angles","title":"Exo angles","text":"<p>get_exo_angles_rad() and get_exo_angles_deg() give the raw exoskeleton angles. These can be indexed with angles[<code>finger_nr</code>][<code>angle_nr</code>]. <code>angle_nr</code> 0 is the splay angle (around z), the rest are flexion angles.</p> <p>The flexion angle definitions are:</p> <ul> <li>When an angle is set to 0, the linkages connected to that joint form a straight line.</li> <li>When the next link bends towards the handpalm, the angle is positive.</li> <li>When the next link bends away from the handpalm, the angle is negative.</li> </ul> <p>The following image defines the angles in a common configuration.</p> <p> </p>"}]}