"""
Robot Hand Mapping Module

This module provides mapping between Rembrandt glove data and robot hand control,
including pinch detection and smooth transitions between normal and pinch modes.

For use see examples/robot_hand_mapper_pbent.py.

Questions? Written by:
- Akshay Radhamohan M
- Amber Elferink
Docs:    https://adjuvo.github.io/SenseGlove-R1-API/robot_hand_mapper/
Support: https://www.senseglove.com/support/
"""
import os
import numpy as np
from dataclasses import dataclass

from . import SG_types as SG_T
from . import SG_devices
from . import SG_math
from SG_API.SG_logger import sg_logger

from dataclasses import dataclass
from typing import Dict, List, Optional, Sequence, Union, Tuple

@dataclass
class PinchConfig:
    """Configuration for pinch detection and mapping"""

    # Name of the configuration
    name: str = "DefaultPinchConfig"

    # Robot Hand Pinch Targets (from percentage bent values)
    # Format: Finger_index: [thumb_abduction, thumb_flexion, finger_flexion]
    # Pinches: Thumb -> Index, Middle, Ring, Pinky
    robot_pinch_targets: Optional[Dict[int, Sequence[float]]] = None
    
    # Abduction threshold for pinch detection (percentage bent)
    thumb_abduction_threshold: float = 9000                 # Minimum thumb abduction to start considering pinch
    
    # Distance thresholds (mm)    
    distance_thresholds: Optional[Dict[str, float]] = None  # [enter_distance, exit_distance, min_distance, max_distance] for pinches
    
    # Smoothing parameters
    blend_weight: float = 0.1
    
    # Which finger to prioritize for pinch detection
    primary_pinch_finger: int = 1                           # 0=thumb, 1=index, 2=middle, 3=ring, 4=pinky
    
    def __post_init__(self):
        # Set default pinch targets if not provided
        if self.robot_pinch_targets is None:
            self.robot_pinch_targets = {
                1: [5000, 9000, 3000],
                2: [4500, 9000, 3500],
                3: [4000, 9000, 3200],
                4: [3500, 9000, 2800],
            }

        if self.distance_thresholds is None:
            self.distance_thresholds = {
                "enter_distance": 40,
                "exit_distance": 55,
                "min_distance": 5,
                "max_distance": 70,
            }
    
    def save_to_py(self, name: str, directory: Optional[str] = None):
        """
        Save this configuration as a human-readable Python file
        """

        root_directory = directory or os.getcwd()
        configs_directory = os.path.join(root_directory, "configs", "robot_hand_mapper")
        os.makedirs(configs_directory, exist_ok=True)

        for pkg_dir in [os.path.join(root_directory, "configs"), configs_directory]:
            init_file = os.path.join(pkg_dir, "__init__.py")
            if not os.path.exists(init_file):
                with open(init_file, "w") as f:
                    f.write("# Auto-generated by RobotHandMapper\n")
                    
        path = os.path.join(configs_directory, f"{name}.py")

        config_name = "".join(part.capitalize() for part in name.split("_"))

        def format_list(lst):
            return "[" + ", ".join(f"{v:.3f}" for v in lst) + "]"

        content = f'''"""
Robot Hand Pinch Configuration
"""

from SG_API.SG_robot_hand_mapper import PinchConfig

{config_name} = PinchConfig(
    # Pinch-Config
    name="{config_name}",

    # Robot Hand Pinch Targets (from percentage bent values)
    # Format: Finger_index: [thumb_abduction, thumb_flexion, finger_flexion]
    robot_pinch_targets={{
        1: {format_list(self.robot_pinch_targets[1])},  # Pinch Index
        2: {format_list(self.robot_pinch_targets[2])},  # Pinch Middle
        3: {format_list(self.robot_pinch_targets[3])},  # Pinch Ring
        4: {format_list(self.robot_pinch_targets[4])},  # Pinch Pinky
    }},

    # Pinch detection parameters
    thumb_abduction_threshold={self.thumb_abduction_threshold},         # Minimum thumb abduction to start considering pinch
    distance_thresholds={{
        "enter_distance": {self.distance_thresholds["enter_distance"]},
        "exit_distance": {self.distance_thresholds["exit_distance"]},
        "min_distance": {self.distance_thresholds["min_distance"]},
        "max_distance": {self.distance_thresholds["max_distance"]},
    }},

    # Blending and detection settings
    blend_weight={self.blend_weight},                   # Weight between thumb abduction and distance influence (0 = only distance, 1 = only thumb)
    primary_pinch_finger={self.primary_pinch_finger},   # 0=thumb, 1=index, 2=middle, 3=ring, 4=pinky
)

config = {config_name}
'''

        with open(path, "w") as f:
            f.write(content)

        return path

@dataclass
class PinchState:
    """Internal state for pinch detection"""
    blend_factor: float = 0.0       # 0.0 = normal mode, 1.0 = pinch mode
    active_pinch_finger: int = 1    # Which finger is being pinched
    pinch_mode_active: bool = False
    last_distance: float = 100.0

class RobotHandMapper:
    """
    Maps Rembrandt glove data to robot hand control with pinch detection.
    """    
    def __init__(self, device_id: int, config: Optional[PinchConfig] = None):
        self.device_id = device_id
        self.config = config or PinchConfig()
        self.state = PinchState()
        self._gui = None
        sg_logger.set_console_level(sg_logger.INFO)

    def register_gui(self, gui):
        """Register a GUI to receive automatic updates."""
        self._gui = gui
        
    def set_pinch_targets(self, finger_index: int, thumb_abduction: float, thumb_flexion: float, finger_flexion: float):
        """
        Set pinch target percentages for a specific finger combination.
        
        Args:
            finger_index: 1=index, 2=middle, 3=ring, 4=pinky
            thumb_abduction: Target robot thumb abduction during pinch (e.g., 8000)
            thumb_flexion: Target robot thumb flexion during pinch (e.g., 9000)
            finger_flexion: Target flexion for the specified finger during pinch (e.g., 3000)

            example:
            mapper.set_pinch_targets(1, 5000, 9000, 3000)  # Robot hand is pinched at: thumb_abd=5000, thumb_flex=9000, index_flex=3000
        """
        try:
            # Validate input
            if finger_index not in (1, 2, 3, 4):
                raise ValueError(f"Invalid finger_index {finger_index}. Use 1-4 for index-pinky.")

            # Update config
            self.config.robot_pinch_targets[finger_index] = [int(thumb_abduction), int(thumb_flexion), int(finger_flexion)]

            sg_logger.info(f"Pinch target set for finger index {finger_index}")
        except Exception as e:
            sg_logger.warn(f"Failed to set pinch target for finger {finger_index}: {e}")

    def set_distance_thresholds(self, enter_distance: float, exit_distance: float, min_distance: float, max_distance: float):
        """Set distance thresholds for pinch detection (in mm)"""
        try:
            self.config.distance_thresholds["enter_distance"] = float(enter_distance)
            self.config.distance_thresholds["exit_distance"]  = float(exit_distance)
            self.config.distance_thresholds["min_distance"]   = float(min_distance)
            self.config.distance_thresholds["max_distance"]   = float(max_distance)

            sg_logger.info(
                f"Distance thresholds updated: "
                f"Enter={self.config.distance_thresholds['enter_distance']} mm, Exit={self.config.distance_thresholds['exit_distance']} mm, "
                f"Min={min_distance} mm, Max={max_distance} mm"
            )
        except Exception as e:
            sg_logger.warn(f"Failed to set distance thresholds: {e}")
    
    def set_thumb_abduction_threshold(self, threshold: float):
        """Set thumb abduction threshold for pinch detection (percentage bent)"""
        try:
            self.config.thumb_abduction_threshold = int(threshold)
            sg_logger.info(f"Thumb Abduction Threshold updated: {self.config.thumb_abduction_threshold}")
        except Exception as e:
            sg_logger.warn(f"Failed to set thumb abduction threshold: {e}")

    def set_blend_weight(self, weight: float):
        """Weight between thumb abduction and distance influence (0 = only distance, 1 = only thumb)"""
        try:
            self.config.blend_weight = np.clip(weight, 0.001, 1.0)
            sg_logger.info(f"Blend Weight updated: {self.config.blend_weight}")
        except Exception as e:
            sg_logger.warn(f"Failed to set blend weight: {e}")
     
    def set_primary_pinch_finger(self, finger_index: int):
        """Set which finger to prioritize for pinch detection (1=index, 2=middle, etc.)"""
        if 1 <= finger_index <= 4:
            self.config.primary_pinch_finger = finger_index
        else:
            raise ValueError("Primary pinch finger must be 1-4 (index-pinky)")
        
    def save_config(self, name: str, directory: Optional[str] = None):
        """
        Save the current pinch configuration associated with this mapper.

        Args:
            name: The name of the configuration file (without extension).
            directory: Optional target directory. Defaults to "os.getcwd()/configs/"

        Returns:
            The full path of the saved Python configuration file.
        """
        if not isinstance(self.config, PinchConfig):
            raise TypeError("Mapper configuration is not a valid PinchConfig instance.")

        try:
            path = self.config.save_to_py(name, directory)
            sg_logger.info(f"RobotHandMapper: Configuration saved as '{name}' in {path}")
        except Exception as e:
            sg_logger.warn(f"RobotHandMapper: Failed to save configuration '{name}': {e}")
            raise

    def _smooth_step(self, value: float, min_val: float, max_val: float) -> float:
        """
        Smooth step function that maps input range to 0.0-1.0 with S-curve.
        
        Args:
            value: Input value
            min_val: Value that maps to 0.0
            max_val: Value that maps to 1.0
            
        Returns:
            Smoothly interpolated value between 0.0 and 1.0
        """
        if max_val <= min_val:
            return 1.0 if value >= max_val else 0.0
            
        # Clamp and normalize to 0-1 range
        t = np.clip((value - min_val) / (max_val - min_val), 0.0, 1.0)
        
        # Apply smooth S-curve (3t² - 2t³)
        return t * t * (3.0 - 2.0 * t)
    
    def _get_device(self):
        """Get the Rembrandt device for this mapper"""
        return SG_devices.get_rembrandt_device(self.device_id)
    
    def _calculate_distance_factor(self):
        # Calculate fingertip distances
        device = self._get_device()
        distances : Sequence[float] = device.get_fingertip_distances()
        
        # Find closest finger to thumb
        closest_distance = min(distances)
        closest_finger = distances.index(closest_distance) + 1

        # Get base thresholds
        base_min = self.config.distance_thresholds["min_distance"]
        base_max = self.config.distance_thresholds["max_distance"]
        
        # Compute scaling factor: +30% for each finger after index
        # Index=1: 1.3x, Middle=2: 1.6x, Ring=3: 1.9x, Pinky=4: 2.2x
        scale = 1.0 + 0.3 * (closest_finger - 1)

        # Apply scaling
        min_distance = base_min * scale
        max_distance = base_max * scale

        # Compute Distance factor (continuous 0.0 to 1.0)
        # Closer distance = higher influence (invert the smooth step)
        distance_factor = 1.0 - self._smooth_step(closest_distance, min_distance, max_distance)
        
        return distance_factor, closest_distance, closest_finger

    def _calculate_blend_factor(self, normal_flex: SG_T.Sequence[Union[int, float]], normal_abd: SG_T.Sequence[Union[int, float]]) -> Tuple[float, float, int]:
        """
        Calculate continuous pinch influence factors (0.0 to 1.0).
        
        Returns:
            (pinch_influence, closest_distance, closest_finger_index)
        """
        
        # Get thumb abduction factor (continuous 0.0 to 1.0)
        thumb_abd_perc = normal_abd[0]
        
        # Smooth step function for thumb abduction
        # Maps abduction percentage to 0.0-1.0 influence
        thumb_min = self.config.thumb_abduction_threshold * 0.2  # starting influence
        thumb_max = self.config.thumb_abduction_threshold * 1.0  # Full influence
        thumb_abd_factor = self._smooth_step(thumb_abd_perc, thumb_min, thumb_max)
        
        self.distance_factor, self.closest_distance, self.closest_finger = self._calculate_distance_factor()
        
        # Combined pinch influence (both factors must contribute)
        w_thumb_abd = self.config.blend_weight
        w_distance  = 1.0 - w_thumb_abd
        blend_factor = ((thumb_abd_factor**w_thumb_abd) * (self.distance_factor**w_distance))**0.9
        blend_factor = np.clip(blend_factor, 0.0, 1.0)

        # blend_factor = thumb_abd_factor * self.distance_factor
        
        return blend_factor, float(self.closest_distance), self.closest_finger
    
    def _update_pinch_state(self, blend_factor: float, distance: float, closest_finger: int):
        """Update internal pinch state using continuous influence"""
        self.state.blend_factor = blend_factor        
        self.state.active_pinch_finger = closest_finger
        self.state.pinch_mode_active = blend_factor > 0.1
        self.state.last_distance = distance
            
    def _get_pinch_targets(self, finger_index: int, normal_flex: SG_T.Sequence[Union[int, float]], normal_abd: SG_T.Sequence[Union[int, float]]) -> Tuple[List[float], List[float]]:
        # Get target percentages for this finger
        thumb_abd, thumb_flex, finger_flex = self.config.robot_pinch_targets.get(finger_index, [5000, 9000, 3000])

        flex_targets = list(normal_flex)              
        flex_targets[0] = float(thumb_flex)
        flex_targets[finger_index] = float(finger_flex)

        abd_targets = list(normal_abd)             
        abd_targets[0] = float(thumb_abd)
                
        return flex_targets, abd_targets
        
    def get_rhm_percentage_bents(self) -> Tuple[SG_T.Sequence[Union[int, float]], SG_T.Sequence[Union[int, float]]]:
        """
        Get percentage bent values with pinch detection and smooth blending.
        
        Returns:
            (flexion_percentages, abduction_percentages) - blended between normal and pinch modes
        """
        # Get normal percentage bent from device
        device = self._get_device()
        normal_flex, normal_abd = device.get_percentage_bents()

        # Calculate blend factors and update pinch state
        blend_factors = self._calculate_blend_factor(normal_flex, normal_abd)
        self._update_pinch_state(*blend_factors)     
        
        # If not in pinch mode or blend factor is minimal, return normal values
        if self.state.blend_factor < 0.001:
            return normal_flex, normal_abd
        
        # Gets the pinch targets (flex and abd) for the active pinch finger
        # The rest remains the norm flex values
        pinch_flex, pinch_abd = self._get_pinch_targets(
            self.state.active_pinch_finger,
            normal_flex,
            normal_abd
        )
                
        # Blend between normal and pinch modes for flexion (uses combined thumb + distance influence)
        self.alpha = self.state.blend_factor
        blended_flex = [(1-self.alpha) * normal + self.alpha * pinch for normal, pinch in zip(normal_flex, pinch_flex)]
        blended_abd = [(1-self.alpha) * normal + self.alpha * pinch for normal, pinch in zip(normal_abd, pinch_abd)]
        
        return blended_flex, blended_abd
    
    def get_pinch_debug_info(self):
        """Get debug information about current pinch state"""        
        device = self._get_device()
        flex_perc_bents, abd_perc_bents = device.get_percentage_bents()
        thumb_abd_perc = abd_perc_bents[0]

        pinch_influence, distance, closest_finger = self._calculate_blend_factor(flex_perc_bents, abd_perc_bents)
        
        # Calculate individual factors for debugging
        thumb_min = self.config.thumb_abduction_threshold * 0.2
        thumb_max = self.config.thumb_abduction_threshold * 1.0
        thumb_factor = self._smooth_step(thumb_abd_perc, thumb_min, thumb_max)
        distance_factor = 1.0 - self._smooth_step(
            distance,
            self.config.distance_thresholds.get("min_distance", 5.0),
            self.config.distance_thresholds.get("max_distance", 30.0)
        )
        
        return {
            'config_name': self.config.name,
            'pinch_mode_active': self.state.pinch_mode_active,
            'blend_factor': self.state.blend_factor,
            'thumb_factor': thumb_factor,
            'distance_factor': distance_factor,
            'thumb_abduction_perc': thumb_abd_perc,
            'thumb_abduction_threshold': self.config.thumb_abduction_threshold,
            'closest_distance': distance,
            'closest_finger': closest_finger,
            'active_pinch_finger': self.state.active_pinch_finger,
            'should_pinch': pinch_influence > 0.1,
            'enter_threshold': self.config.distance_thresholds.get("enter_distance", 20.0),
            'exit_threshold': self.config.distance_thresholds.get("exit_distance", 30.0),
        }
    
    def apply_config(self, config: PinchConfig):
        """Apply a new PinchConfig instance to this mapper"""

        if not isinstance(config, PinchConfig):
            raise TypeError("apply_config() expects a PinchConfig instance.")

        try:
            self.config = config
            self.config_name = getattr(config, "name", "DefaultConfig")
            sg_logger.info(f"RobotHandMapper: Applied Pinch-Config '{self.config_name}' successfully.")
        except Exception as e:
            sg_logger.warn(f"Failed to apply Pinch-Config: {e}")
            raise
    
    def update_mapper_gui(self):
        """Update the latest device data to the registered GUI."""
        if not self._gui:
            return
        
        try:
            device = self._get_device()           
            normal_flex, normal_abd = device.get_percentage_bents()
            robot_flex, robot_abd = self.get_rhm_percentage_bents()
            debug = self.get_pinch_debug_info()
            self._gui.data_signaler.update_display.emit(normal_flex, robot_flex, normal_abd, robot_abd, debug)

        except Exception as e:
            sg_logger.warn(f"Failed to update GUI: {e}")
